{"status":"ok","feed":{"url":"https://medium.com/feed/@jp.saldivarrojas","title":"Stories by Juan Pablo Saldivar Rojas on Medium","link":"https://medium.com/@jp.saldivarrojas?source=rss-e33d48ebdf93------2","author":"","description":"Stories by Juan Pablo Saldivar Rojas on Medium","image":"https://cdn-images-1.medium.com/fit/c/150/150/1*LMCswkbg_dpse8X8gGTf1w.jpeg"},"items":[{"title":"JUnit y Mockito\u200a\u2014\u200aComenzando mis primeros test","pubDate":"2021-11-23 02:16:59","link":"https://medium.com/@jp.saldivarrojas/junit-y-mockito-comenzando-mis-primeros-test-be916abb4b13?source=rss-e33d48ebdf93------2","guid":"https://medium.com/p/be916abb4b13","author":"Juan Pablo Saldivar Rojas","thumbnail":"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=be916abb4b13","description":"\n<h3>JUnit y Mockito\u200a\u2014\u200aComenzando mis primeros\u00a0test</h3>\n<p>Comenzando un proyecto nuevo de Testing usando JUnit y Mockito\u00a0\u2026</p>\n<h3>JUnit</h3>\n<p>Es un framework open source que permite realizar pruebas unitarias y de integraci\u00f3n sobre sistemas en JAVA. Este framework disponibiliza herramientas, clases y m\u00e9todos que simplifican la elaboraci\u00f3n de las pruebas de sistemas.</p>\n<h4>Algunos t\u00e9rminos\u00a0clave:</h4>\n<h4>M\u00e9todos</h4>\n<ul>\n<li>setUp: Permite asignar valores iniciales a las variables antes de iniciar cada\u00a0test.</li>\n<li>tearDown: Es llamada despues de cada test, usada para liberar recursos.</li>\n<li>test: Las pruebas a\u00a0realizar</li>\n</ul>\n<p>Tambien se considera que pueden existir otros m\u00e9todos para ser un usadas por las\u00a0pruebas</p>\n<h4>Anotaciones</h4>\n<ul>\n<li>\n<a href=\"http://twitter.com/RunWith\">@RunWith</a>: Se le asigna una clase a la que JUnit invocar\u00e1 en lugar del ejecutor por defecto de\u00a0JUnit</li>\n<li>\n<a href=\"http://twitter.com/Before\">@Before</a>: Indicamos que el siguiente m\u00e9todo se debe ejecutar antes de cada test (precede al m\u00e9todo setUp). Si tiene que preceder al m\u00e9todo setUpClass, la notaci\u00f3n ser\u00e1 \u201c<a href=\"http://twitter.com/BeforeClass\">@BeforeClass</a>\u201d</li>\n<li>\n<a href=\"http://twitter.com/After\">@After</a>: Indicamos que el siguiente m\u00e9todo se debe ejecutar despu\u00e9s de cada test (precede al m\u00e9todo tearDown). Si tiene que preceder al m\u00e9todo tearDownClass, la notaci\u00f3n ser\u00e1 \u201c<a href=\"http://twitter.com/AfterClass\">@AfterClass</a>\u201d</li>\n<li>\n<a href=\"http://twitter.com/Test\">@Test</a>: Indicamos a Junit que se trata de un m\u00e9todo de Test. En versiones anteriores de JUnit los m\u00e9todos ten\u00edan que tener un nombre con la siguiente estructura: \u201cTest\u201d. Con esta notaci\u00f3n colocada delante de los m\u00e9todos podemos elegir el nombre libremente.</li>\n</ul>\n<p>Listado completo de anotaciones: <a href=\"https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations\">JUnit\u200a\u2014\u200aAnotaciones</a></p>\n<h4>Funciones de aceptaci\u00f3n/rechazo</h4>\n<ul>\n<li>sertArrayEquals: Recibe como par\u00e1metro dos arrays y comprueba si son iguales. Devuelve assertionError si no se produce el resultado esperado</li>\n<li>sertEquals: Realiza la comprobaci\u00f3n entre dos valores de tipo num\u00e9rico. Devuelve assertionError si no se produce el resultado esperado</li>\n<li>sertTrue: Comprueba si una condici\u00f3n se cumple. Devuelve assertionError si no se produce el resultado esperado</li>\n<li>il: devuelve una alerta informando del fallo en el\u00a0test</li>\n</ul>\n<h4>Ejemplo</h4>\n<a href=\"https://medium.com/media/e5e7aeb54ccca046dcaf6549ca3da847/href\">https://medium.com/media/e5e7aeb54ccca046dcaf6549ca3da847/href</a><h3>Mockito</h3>\n<p>Mockito es una librer\u00eda Java que permite simular el comportamiento de una clase de forma din\u00e1mica. De esta forma nos aislamos de las dependencias con otras clases y s\u00f3lo testeamos la funcionalidad concreta que queremos.</p>\n<p>El ejemplo cl\u00e1sico de un objeto mock es un proveedor de datos, cuando se ejecuta la aplicaci\u00f3n el componente se conectar\u00e1 a una base de datos y proveer\u00e1 datos reales, pero cuando se ejecuta un test unitario lo que buscamos es aislarlo y para esto necesitamos un objeto mock que simular\u00e1 la fuente de datos, esto asegurar\u00e1 que las condiciones de prueba sean siempre las\u00a0mismas.</p>\n<p>La simulaci\u00f3n del comportamiento de una clase se hace mediante los \u201cdobles\u201d que pueden ser de distintos tipos:</p>\n<ul>\n<li>Dummy: Son objetos que se utilizan para realizar llamadas a otros m\u00e9todos, pero no se\u00a0usan.</li>\n<li>Stub: es como un dummy ya que sus m\u00e9todos no hacen nada, pero devuelven cierto valor que necesitamos para ejecutar nuestro test con respecto a ciertas condiciones.</li>\n<li>Spy: Es un objeto real que permite verificar el uso que se hace del propio objeto, por ejemplo el n\u00famero de veces que se ejecuta un m\u00e9todo o los argumentos que se le\u00a0pasan.</li>\n<li>Mock: Es un stub en el que sus m\u00e9todos s\u00ed implementan un comportamiento, pues esperan recibir unos valores y en funci\u00f3n de ellos devuelve una respuesta.</li>\n<li>Fake: Son objetos que tienen una implementaci\u00f3n que funciona pero que no son apropiados para usar en producci\u00f3n (por ejemplo, una implementaci\u00f3n de HttpSession).</li>\n</ul>\n<h4>Ejemplos usando\u00a0mockito</h4>\n<h4>Ejemplo 1: Verificar comportamiento</h4>\n<pre>//creacion de mock<br>List mockedList = mock(List.class);</pre>\n<pre>//utilizando el mock object</pre>\n<pre>mockedList.add(\"one\");<br>mockedList.clear();</pre>\n<pre>//verificacion<br>verify(mockedList).add(\"one\");<br>verify(mockedList).clear();</pre>\n<h4>Ejmplo 2:\u00a0Stubbing</h4>\n<p>Tambi\u00e9n podemos programar el comportamiento de los mocks, indicando qu\u00e9<br>deben devolver ciertos\u00a0m\u00e9todos.</p>\n<pre>//se pueden hacer mock de clases concretas, no solo interfaces<br>LinkedList mockedList = mock(LinkedList.class);</pre>\n<pre>//stubbing<br>when(mockedList.get(0)).thenReturn(\"first\");<br>when(mockedList.get(1)).thenThrow(new RuntimeException());</pre>\n<pre>//imprime \"first\"<br>System.out.println(mockedList.get(0));</pre>\n<pre>//lanza runtime exception<br>System.out.println(mockedList.get(1));</pre>\n<pre>//imprime \"null\" porque no se ha hecho stubbing de get(999)<br>System.out.println(mockedList.get(999));</pre>\n<pre>verify(mockedList).get(0);</pre>\n<p>Por defecto todos los m\u00e9todos que devuelven valores de un mock devuelven<br>null, una colecci\u00f3n vac\u00eda o el tipo de dato primitivo apropiado.</p>\n<h4>Ejmplo 3: Argument\u00a0matchers</h4>\n<p>Los arguments matchers permiten realizar llamadas a m\u00e9todos mediante<br>\u2018comodines\u2019, de forma que los p\u00e1rametros a los mismos no se tengan que definir expl\u00edcitamente:</p>\n<pre>//stubbing usando anyInt() argument matcher<br>when(mockedList.get(anyInt())).thenReturn(\"element\");</pre>\n<pre>//stubbing usando hamcrest (libreria de matchers) (digamos que isValid() devuelve tu propio matcher):<br>when(mockedList.contains(argThat(isValid()))).thenReturn(\"element\");</pre>\n<pre>//imprime \"element\"<br>System.out.println(mockedList.get(999));</pre>\n<pre>//tambien se puede verificar usando argument matchers<br>verify(mockedList).get(anyInt());</pre>\n<p>Argument matchers permiten realizar stubbing o verificaciones muy flexibles.<br>pod\u00e9is ver mas en <a href=\"http://mockito.googlecode.com/svn/branches/1.7/javadoc/org/mockito/Matchers.html\">http://mockito.googlecode.com/svn/branches/1.7/javadoc/org/mockito/Matchers.html</a></p>\n<h4>Verficiando el numero exacto de invocaciones, al menos X, o ninguna invocaci\u00f3n</h4>\n<p>Vamos a ver ahora c\u00f3mo verificar si se ha un cumplido un n\u00famero m\u00ednimo o<br>m\u00e1ximo de llamadas al\u00a0mock:</p>\n<pre>//usando mock<br>mockedList.add(\"once\");<br>mockedList.add(\"twice\");<br>mockedList.add(\"twice\");</pre>\n<pre>mockedList.add(\"three times\");<br>mockedList.add(\"three times\");<br>mockedList.add(\"three times\");</pre>\n<pre>//las dos verificaciones siguientes trabajan de la misma manera (times(1) se usa por defecto)<br>verify(mockedList).add(\"once\");<br>verify(mockedList, times(1)).add(\"once\");</pre>\n<pre>//verificacion de numero exacto de invaciones<br>verify(mockedList, times(2)).add(\"twice\");<br>verify(mockedList, times(3)).add(\"three times\");</pre>\n<pre>//verificacion utilizando never. never() es un alias de times(0)<br>verify(mockedList, never()).add(\"never happened\");</pre>\n<pre>//verificacion utilizando atLeast()/atMost()<br>verify(mockedList, atLeastOnce()).add(\"three times\");<br>verify(mockedList, atLeast(2)).add(\"five times\");<br>verify(mockedList, atMost(5)).add(\"three times\");</pre>\n<h4>Verificaciones en\u00a0orden</h4>\n<p>Si necesitamos que varios mock necesiten llevar un orden espec\u00edfico en las<br>llamadas lo podemos realizar de la siguiente manera:</p>\n<pre>List firstMock = mock(List.class);<br>List secondMock = mock(List.class);<br><br>//usando mocks<br>firstMock.add(\"was called first\");<br>secondMock.add(\"was called second\");<br><br>//creamos un objeto inOrder, pasando los mocks que necesitan verificarse en orden<br>InOrder inOrder = inOrder(firstMock, secondMock);<br><br>//verficamos que firstMock ha sido invocado antes que secondMock<br>inOrder.verify(firstMock).add(\"was called first\");<br>inOrder.verify(secondMock).add(\"was called second\");</pre>\n<p>Realizar verificaciones en orden son muy flexibles. no es necesario<br>verificar todas las interacciones, si no s\u00f3lo aquellas que necesitamos.</p>\n<h4>Asegurandonos que alguna(s) interaccion(es) nunca ocurren en un\u00a0mock</h4>\n<pre>//usando mocks - solo se interactua sobre mockOne<br>mockOne.add(\"one\");<br><br>//verificacion ordinaria<br>verify(mockOne).add(\"one\");<br><br>//verificamos que el metodo nunca ha sido llamado en el mock<br>verify(mockOne, never()).add(\"two\");<br><br>//verificamos que otros mocks no obtienen interactuaciones<br>verifyZeroInteractions(mockTwo, mockThree);</pre>\n<h4>@Mock</h4>\n<p>Nos permite realizar mocks anotando el c\u00f3digo, y as\u00ed el mismo queda m\u00e1s<br>claro y\u00a0limpio.</p>\n<pre>public class ArticleManagerTest { <br><br><a href=\"http://twitter.com/Mock\">@Mock</a> private ArticleCalculator calculator;<br><a href=\"http://twitter.com/Mock\">@Mock</a> private ArticleDatabase database;<br><a href=\"http://twitter.com/Mock\">@Mock</a> private UserProvider userProvider;<br><br>       private ArticleManager manager;<br>       ...<br>}</pre>\n<p>Importante! La siguiente llamada debe encontrarse en algun lugar de una<br>clase base o del test\u00a0runner:</p>\n<pre>MockitoAnnotations.initMocks(testClass);</pre>\n<h3>JUnit Vs\u00a0Mockito</h3>\n<p>JUnit es un marco que ayuda a escribir y ejecutar sus pruebas unitarias y Mockito (o cualquier otra herramienta de burla) es un marco que utiliza espec\u00edficamente para escribir de manera eficiente cierto tipo de\u00a0pruebas.</p>\n<p>Un aspecto central en las pruebas unitarias es el hecho de que desea aislar su \u201cclase bajo prueba\u201d de cualquier otra cosa en el mundo. Para hacerlo, a menudo tiene que crear \u201cdobles de prueba\u201d que proporcione a un objeto de su \u201cclase bajo prueba\u201d. Puede crear todos esos \u201cdobles de prueba\u201d manualmente; o usas un marco burl\u00f3n que <strong>genera</strong> objeto de una clase determinada para ti usando t\u00e9cnicas de reflexi\u00f3n. Curiosamente, algunas personas abogan por nunca usar marcos burlones; pero sinceramente: no me puedo imaginar haciendo\u00a0eso.</p>\n<p>En otras palabras: definitivamente puedes usar JUnit sin usar un marco burl\u00f3n. Lo mismo es cierto para la direcci\u00f3n inversa; pero en realidad, no hay muchas buenas razones por las que desear\u00eda usar Mockito para otra cosa que no sea la prueba de\u00a0unidad.</p>\n<h4>Referencias:</h4>\n<ul>\n<li><a href=\"http://www.juntadeandalucia.es/servicios/madeja/contenido/recurso/248\">Inicio en\u00a0JUnit</a></li>\n<li><a href=\"https://blog.softtek.com/es/testing-unitario\">Testing unitario</a></li>\n<li><a href=\"https://www.it-swarm-es.com/es/unit-testing/\">Unit testing</a></li>\n<li><a href=\"https://www.adictosaltrabajo.com/2009/01/29/mockito\">Uso de\u00a0mockito</a></li>\n</ul>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=be916abb4b13\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<h3>JUnit y Mockito\u200a\u2014\u200aComenzando mis primeros\u00a0test</h3>\n<p>Comenzando un proyecto nuevo de Testing usando JUnit y Mockito\u00a0\u2026</p>\n<h3>JUnit</h3>\n<p>Es un framework open source que permite realizar pruebas unitarias y de integraci\u00f3n sobre sistemas en JAVA. Este framework disponibiliza herramientas, clases y m\u00e9todos que simplifican la elaboraci\u00f3n de las pruebas de sistemas.</p>\n<h4>Algunos t\u00e9rminos\u00a0clave:</h4>\n<h4>M\u00e9todos</h4>\n<ul>\n<li>setUp: Permite asignar valores iniciales a las variables antes de iniciar cada\u00a0test.</li>\n<li>tearDown: Es llamada despues de cada test, usada para liberar recursos.</li>\n<li>test: Las pruebas a\u00a0realizar</li>\n</ul>\n<p>Tambien se considera que pueden existir otros m\u00e9todos para ser un usadas por las\u00a0pruebas</p>\n<h4>Anotaciones</h4>\n<ul>\n<li>\n<a href=\"http://twitter.com/RunWith\">@RunWith</a>: Se le asigna una clase a la que JUnit invocar\u00e1 en lugar del ejecutor por defecto de\u00a0JUnit</li>\n<li>\n<a href=\"http://twitter.com/Before\">@Before</a>: Indicamos que el siguiente m\u00e9todo se debe ejecutar antes de cada test (precede al m\u00e9todo setUp). Si tiene que preceder al m\u00e9todo setUpClass, la notaci\u00f3n ser\u00e1 \u201c<a href=\"http://twitter.com/BeforeClass\">@BeforeClass</a>\u201d</li>\n<li>\n<a href=\"http://twitter.com/After\">@After</a>: Indicamos que el siguiente m\u00e9todo se debe ejecutar despu\u00e9s de cada test (precede al m\u00e9todo tearDown). Si tiene que preceder al m\u00e9todo tearDownClass, la notaci\u00f3n ser\u00e1 \u201c<a href=\"http://twitter.com/AfterClass\">@AfterClass</a>\u201d</li>\n<li>\n<a href=\"http://twitter.com/Test\">@Test</a>: Indicamos a Junit que se trata de un m\u00e9todo de Test. En versiones anteriores de JUnit los m\u00e9todos ten\u00edan que tener un nombre con la siguiente estructura: \u201cTest\u201d. Con esta notaci\u00f3n colocada delante de los m\u00e9todos podemos elegir el nombre libremente.</li>\n</ul>\n<p>Listado completo de anotaciones: <a href=\"https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations\">JUnit\u200a\u2014\u200aAnotaciones</a></p>\n<h4>Funciones de aceptaci\u00f3n/rechazo</h4>\n<ul>\n<li>sertArrayEquals: Recibe como par\u00e1metro dos arrays y comprueba si son iguales. Devuelve assertionError si no se produce el resultado esperado</li>\n<li>sertEquals: Realiza la comprobaci\u00f3n entre dos valores de tipo num\u00e9rico. Devuelve assertionError si no se produce el resultado esperado</li>\n<li>sertTrue: Comprueba si una condici\u00f3n se cumple. Devuelve assertionError si no se produce el resultado esperado</li>\n<li>il: devuelve una alerta informando del fallo en el\u00a0test</li>\n</ul>\n<h4>Ejemplo</h4>\n<a href=\"https://medium.com/media/e5e7aeb54ccca046dcaf6549ca3da847/href\">https://medium.com/media/e5e7aeb54ccca046dcaf6549ca3da847/href</a><h3>Mockito</h3>\n<p>Mockito es una librer\u00eda Java que permite simular el comportamiento de una clase de forma din\u00e1mica. De esta forma nos aislamos de las dependencias con otras clases y s\u00f3lo testeamos la funcionalidad concreta que queremos.</p>\n<p>El ejemplo cl\u00e1sico de un objeto mock es un proveedor de datos, cuando se ejecuta la aplicaci\u00f3n el componente se conectar\u00e1 a una base de datos y proveer\u00e1 datos reales, pero cuando se ejecuta un test unitario lo que buscamos es aislarlo y para esto necesitamos un objeto mock que simular\u00e1 la fuente de datos, esto asegurar\u00e1 que las condiciones de prueba sean siempre las\u00a0mismas.</p>\n<p>La simulaci\u00f3n del comportamiento de una clase se hace mediante los \u201cdobles\u201d que pueden ser de distintos tipos:</p>\n<ul>\n<li>Dummy: Son objetos que se utilizan para realizar llamadas a otros m\u00e9todos, pero no se\u00a0usan.</li>\n<li>Stub: es como un dummy ya que sus m\u00e9todos no hacen nada, pero devuelven cierto valor que necesitamos para ejecutar nuestro test con respecto a ciertas condiciones.</li>\n<li>Spy: Es un objeto real que permite verificar el uso que se hace del propio objeto, por ejemplo el n\u00famero de veces que se ejecuta un m\u00e9todo o los argumentos que se le\u00a0pasan.</li>\n<li>Mock: Es un stub en el que sus m\u00e9todos s\u00ed implementan un comportamiento, pues esperan recibir unos valores y en funci\u00f3n de ellos devuelve una respuesta.</li>\n<li>Fake: Son objetos que tienen una implementaci\u00f3n que funciona pero que no son apropiados para usar en producci\u00f3n (por ejemplo, una implementaci\u00f3n de HttpSession).</li>\n</ul>\n<h4>Ejemplos usando\u00a0mockito</h4>\n<h4>Ejemplo 1: Verificar comportamiento</h4>\n<pre>//creacion de mock<br>List mockedList = mock(List.class);</pre>\n<pre>//utilizando el mock object</pre>\n<pre>mockedList.add(\"one\");<br>mockedList.clear();</pre>\n<pre>//verificacion<br>verify(mockedList).add(\"one\");<br>verify(mockedList).clear();</pre>\n<h4>Ejmplo 2:\u00a0Stubbing</h4>\n<p>Tambi\u00e9n podemos programar el comportamiento de los mocks, indicando qu\u00e9<br>deben devolver ciertos\u00a0m\u00e9todos.</p>\n<pre>//se pueden hacer mock de clases concretas, no solo interfaces<br>LinkedList mockedList = mock(LinkedList.class);</pre>\n<pre>//stubbing<br>when(mockedList.get(0)).thenReturn(\"first\");<br>when(mockedList.get(1)).thenThrow(new RuntimeException());</pre>\n<pre>//imprime \"first\"<br>System.out.println(mockedList.get(0));</pre>\n<pre>//lanza runtime exception<br>System.out.println(mockedList.get(1));</pre>\n<pre>//imprime \"null\" porque no se ha hecho stubbing de get(999)<br>System.out.println(mockedList.get(999));</pre>\n<pre>verify(mockedList).get(0);</pre>\n<p>Por defecto todos los m\u00e9todos que devuelven valores de un mock devuelven<br>null, una colecci\u00f3n vac\u00eda o el tipo de dato primitivo apropiado.</p>\n<h4>Ejmplo 3: Argument\u00a0matchers</h4>\n<p>Los arguments matchers permiten realizar llamadas a m\u00e9todos mediante<br>\u2018comodines\u2019, de forma que los p\u00e1rametros a los mismos no se tengan que definir expl\u00edcitamente:</p>\n<pre>//stubbing usando anyInt() argument matcher<br>when(mockedList.get(anyInt())).thenReturn(\"element\");</pre>\n<pre>//stubbing usando hamcrest (libreria de matchers) (digamos que isValid() devuelve tu propio matcher):<br>when(mockedList.contains(argThat(isValid()))).thenReturn(\"element\");</pre>\n<pre>//imprime \"element\"<br>System.out.println(mockedList.get(999));</pre>\n<pre>//tambien se puede verificar usando argument matchers<br>verify(mockedList).get(anyInt());</pre>\n<p>Argument matchers permiten realizar stubbing o verificaciones muy flexibles.<br>pod\u00e9is ver mas en <a href=\"http://mockito.googlecode.com/svn/branches/1.7/javadoc/org/mockito/Matchers.html\">http://mockito.googlecode.com/svn/branches/1.7/javadoc/org/mockito/Matchers.html</a></p>\n<h4>Verficiando el numero exacto de invocaciones, al menos X, o ninguna invocaci\u00f3n</h4>\n<p>Vamos a ver ahora c\u00f3mo verificar si se ha un cumplido un n\u00famero m\u00ednimo o<br>m\u00e1ximo de llamadas al\u00a0mock:</p>\n<pre>//usando mock<br>mockedList.add(\"once\");<br>mockedList.add(\"twice\");<br>mockedList.add(\"twice\");</pre>\n<pre>mockedList.add(\"three times\");<br>mockedList.add(\"three times\");<br>mockedList.add(\"three times\");</pre>\n<pre>//las dos verificaciones siguientes trabajan de la misma manera (times(1) se usa por defecto)<br>verify(mockedList).add(\"once\");<br>verify(mockedList, times(1)).add(\"once\");</pre>\n<pre>//verificacion de numero exacto de invaciones<br>verify(mockedList, times(2)).add(\"twice\");<br>verify(mockedList, times(3)).add(\"three times\");</pre>\n<pre>//verificacion utilizando never. never() es un alias de times(0)<br>verify(mockedList, never()).add(\"never happened\");</pre>\n<pre>//verificacion utilizando atLeast()/atMost()<br>verify(mockedList, atLeastOnce()).add(\"three times\");<br>verify(mockedList, atLeast(2)).add(\"five times\");<br>verify(mockedList, atMost(5)).add(\"three times\");</pre>\n<h4>Verificaciones en\u00a0orden</h4>\n<p>Si necesitamos que varios mock necesiten llevar un orden espec\u00edfico en las<br>llamadas lo podemos realizar de la siguiente manera:</p>\n<pre>List firstMock = mock(List.class);<br>List secondMock = mock(List.class);<br><br>//usando mocks<br>firstMock.add(\"was called first\");<br>secondMock.add(\"was called second\");<br><br>//creamos un objeto inOrder, pasando los mocks que necesitan verificarse en orden<br>InOrder inOrder = inOrder(firstMock, secondMock);<br><br>//verficamos que firstMock ha sido invocado antes que secondMock<br>inOrder.verify(firstMock).add(\"was called first\");<br>inOrder.verify(secondMock).add(\"was called second\");</pre>\n<p>Realizar verificaciones en orden son muy flexibles. no es necesario<br>verificar todas las interacciones, si no s\u00f3lo aquellas que necesitamos.</p>\n<h4>Asegurandonos que alguna(s) interaccion(es) nunca ocurren en un\u00a0mock</h4>\n<pre>//usando mocks - solo se interactua sobre mockOne<br>mockOne.add(\"one\");<br><br>//verificacion ordinaria<br>verify(mockOne).add(\"one\");<br><br>//verificamos que el metodo nunca ha sido llamado en el mock<br>verify(mockOne, never()).add(\"two\");<br><br>//verificamos que otros mocks no obtienen interactuaciones<br>verifyZeroInteractions(mockTwo, mockThree);</pre>\n<h4>@Mock</h4>\n<p>Nos permite realizar mocks anotando el c\u00f3digo, y as\u00ed el mismo queda m\u00e1s<br>claro y\u00a0limpio.</p>\n<pre>public class ArticleManagerTest { <br><br><a href=\"http://twitter.com/Mock\">@Mock</a> private ArticleCalculator calculator;<br><a href=\"http://twitter.com/Mock\">@Mock</a> private ArticleDatabase database;<br><a href=\"http://twitter.com/Mock\">@Mock</a> private UserProvider userProvider;<br><br>       private ArticleManager manager;<br>       ...<br>}</pre>\n<p>Importante! La siguiente llamada debe encontrarse en algun lugar de una<br>clase base o del test\u00a0runner:</p>\n<pre>MockitoAnnotations.initMocks(testClass);</pre>\n<h3>JUnit Vs\u00a0Mockito</h3>\n<p>JUnit es un marco que ayuda a escribir y ejecutar sus pruebas unitarias y Mockito (o cualquier otra herramienta de burla) es un marco que utiliza espec\u00edficamente para escribir de manera eficiente cierto tipo de\u00a0pruebas.</p>\n<p>Un aspecto central en las pruebas unitarias es el hecho de que desea aislar su \u201cclase bajo prueba\u201d de cualquier otra cosa en el mundo. Para hacerlo, a menudo tiene que crear \u201cdobles de prueba\u201d que proporcione a un objeto de su \u201cclase bajo prueba\u201d. Puede crear todos esos \u201cdobles de prueba\u201d manualmente; o usas un marco burl\u00f3n que <strong>genera</strong> objeto de una clase determinada para ti usando t\u00e9cnicas de reflexi\u00f3n. Curiosamente, algunas personas abogan por nunca usar marcos burlones; pero sinceramente: no me puedo imaginar haciendo\u00a0eso.</p>\n<p>En otras palabras: definitivamente puedes usar JUnit sin usar un marco burl\u00f3n. Lo mismo es cierto para la direcci\u00f3n inversa; pero en realidad, no hay muchas buenas razones por las que desear\u00eda usar Mockito para otra cosa que no sea la prueba de\u00a0unidad.</p>\n<h4>Referencias:</h4>\n<ul>\n<li><a href=\"http://www.juntadeandalucia.es/servicios/madeja/contenido/recurso/248\">Inicio en\u00a0JUnit</a></li>\n<li><a href=\"https://blog.softtek.com/es/testing-unitario\">Testing unitario</a></li>\n<li><a href=\"https://www.it-swarm-es.com/es/unit-testing/\">Unit testing</a></li>\n<li><a href=\"https://www.adictosaltrabajo.com/2009/01/29/mockito\">Uso de\u00a0mockito</a></li>\n</ul>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=be916abb4b13\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":[]}]}